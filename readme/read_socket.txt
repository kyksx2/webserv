MISE EN PLACE D UN SERVEUR BASIQUE TCP :

***SOCKET***
socket : connecteur reseau --> point de communication
mon serveur -> un socket "ecoute"
le client -> un socket "parle"

----------------------------------------------------------------------------
**difference pipe et socket :**

pipe : communication local entre 2 processus sur une meme machine
       gerer par le noyau sans passer par le reseau
socket : communication reseau, permet a 2 programmes sur la meme machine
         ou non de communiquer via TCP/IP ou UDP

exemple imager :
pipe = tuyau entre 2 programmes sur la meme machine (pas besoin d adresse, flux d octet direct).
socket = cable reseau entre 2 ordinateurs (chaque extremite a une adresse).
-----------------------------------------------------------------------------

SOCKET:
       - de flux (TCP) : connecte, fiable, bidirectionnel, ordonne
       - de datagramme (UDP) : non connecter, non fiable, MAIS plus rapide

 -- initialisation du socket (creation):
 https://man7.org/linux/man-pages/man2/socket.2.html
 int socket(int domain, int type, int protocol) --> int socket(AF_INET, SOCK_STREAM, 0)
 protocol non specifie donc 0.

 -- struct sockaddr_in (configuration du socket): decrit l'adresse d'une socket
 https://man7.org/linux/man-pages/man3/sockaddr.3type.html

 -- bind (liaison du socket): lie les info mise a un socket
 https://man7.org/linux/man-pages/man2/bind.2.html
 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
 sockfd --> generer par fct socket
 *addr --> struct sockaddr_in
 addrlen --> sizeof struct sockaddr_in

 -- listen (attente de connections): permet d'attendre des connections sur un socket.
 https://man7.org/linux/man-pages/man2/listen.2.html
 int listen(int sockfd, int backlog);
 sockfd --> generer par fct socket
 backlog --> limite le nombre de client accepter

 -- accept: accepte une connexion a une socket..
 https://man7.org/linux/man-pages/man2/accept.2.html
 int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
 socklen_t* ne peut pas etre envoyer en sizeof, elle doit etre recaster en (socklen_t*)&x
 !!! renvoi le FD du client !!!

 -- reception du message:
 creer -> char buffer[BUFFER_SIZE] (1024 || 2048 -> multiple de 2)
 https://man7.org/linux/man-pages/man2/recv.2.html
 ssize_t recv(int sockfd, void buf[size], size_t size, int flags)
 sockfd --> generer par accept
 buf[size] --> buffer creer au dessus
 size --> BUFFER_SIZE
 flags --> 0 (pas d'element a indiquer ici mais voir la doc)
 !! checker que la reception se passe bien avec un if !!

 -- envoi du message:
 creer -> std::string message = "bonjour, je suis le serveur."
 https://man7.org/linux/man-pages/man2/send.2.html
 ssize_t send(int sockfd, const void buf[size], size_t size, int flags)
 sockfd --> generer par accept
 buf[size] --> message creer au dessus
 size --> taille message
 flags --> 0 (pas d'element a indiquer ici mais voir la doc)
 !! checker que l'envoi c'est bien passe avec un if !!

 -- fermeture du fd:
 utiliser close() avec le socket creer

----------------------------------------------------------------------------

Fonction fcntl():

fcntl ==> "file controle"
fonction qui permet de manipuler les proprietes d'un FD ouvert

Dans ce cas on en a besoin pour passer en mode NON BLOQUANT, c'est a dire que
le programme ne s'arretera pas meme si une operation sur un client echoue
car on doit gerer plusieurs clients en meme temps.

int fcntl(int fd, int cmd, ...)
 - fd = le fd viser
 - cmd = la commande a executer
 - arg(...) = optionnel en fonction de la commande

 https://man7.org/linux/man-pages/man2/fcntl.2.html